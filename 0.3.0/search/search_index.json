{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Actyon actyon can be used natively or via the provided interface extensions Flux and State Machine . Simple Usage Define an interface class for your actyon, like MyResult . Create a producer with return annotation MyResult or List[MyResult] : from actyon import produce @produce(\"my_actyon\") async def my_producer(dependency: MyDependency) -> MyResult: # your magic code ... return my_result Create a consumer taking exactly one parameter of type List[MyResult] : from actyon import consume @consume(\"my_actyon\") async def my_consumer(results: List[MyResult]) -> None: # do whatever you want with your results Finally, execute your actyon: from actyon import execute await execute(\"my_actyon\", dependencies) By the way, dependencies can be any kind of object (iterable or simply an instance of your favorite class). By handing it over to the execute method, it will be crawled and necessary objects will be extracted and handed over to all producers accordingly. Working with Actyon Create an Actyon : from actyon import Actyon my_actyon: Actyon = Actyon[MyResult](\"my_actyon\") Create a producer: @my_actyon.producer async def my_producer(dependency: MyDependency) -> MyResult: # your magic code ... return my_result Create a consumer: @my_actyon.consumer async def my_consumer(results: List[MyResult]) -> None: # do whatever you want with your results Execute: await my_actyon.execute(dependencies) Example: Github API Please find the code here .","title":"Actyon"},{"location":"#actyon","text":"actyon can be used natively or via the provided interface extensions Flux and State Machine .","title":"Actyon"},{"location":"#simple-usage","text":"Define an interface class for your actyon, like MyResult . Create a producer with return annotation MyResult or List[MyResult] : from actyon import produce @produce(\"my_actyon\") async def my_producer(dependency: MyDependency) -> MyResult: # your magic code ... return my_result Create a consumer taking exactly one parameter of type List[MyResult] : from actyon import consume @consume(\"my_actyon\") async def my_consumer(results: List[MyResult]) -> None: # do whatever you want with your results Finally, execute your actyon: from actyon import execute await execute(\"my_actyon\", dependencies) By the way, dependencies can be any kind of object (iterable or simply an instance of your favorite class). By handing it over to the execute method, it will be crawled and necessary objects will be extracted and handed over to all producers accordingly.","title":"Simple Usage"},{"location":"#working-with-actyon","text":"Create an Actyon : from actyon import Actyon my_actyon: Actyon = Actyon[MyResult](\"my_actyon\") Create a producer: @my_actyon.producer async def my_producer(dependency: MyDependency) -> MyResult: # your magic code ... return my_result Create a consumer: @my_actyon.consumer async def my_consumer(results: List[MyResult]) -> None: # do whatever you want with your results Execute: await my_actyon.execute(dependencies)","title":"Working with Actyon"},{"location":"#example-github-api","text":"Please find the code here .","title":"Example: Github API"},{"location":"flux/","text":"Flux Usage Define your store, like MyStore . Create a flux environment including the initial value for your store. from actyon.flux import Flux flux: Flux[MyStore] = Flux[MyStore](initial=initial_store) Create reducers like this: @flux.reducer async def my_reducer(state: MyStore, action: Flux.Action) -> MyState: # your magic code ... return state Optionally, add effects that are executed after successful reducers: @flux.effect(\"my_reducer\") async def my_effect(state: MyStore) -> None: # do whatever you want with the state, just don't expect alterations will affect other functions Finally, run your flux! await flux.run() await flux.dispatch(\"my_reducer\") await flux.done() Example: Counter Please find the code here . graph TD A[Run] --> B(Increment) B --> C{Is value < 10 ?} C --> B C -->D[Done] Experimental Registering a hook introduces a neat debug output on transitions: from actyon.flux import FluxHook flux: Flux[MyStore] = Flux[MyStore](initial=initial_store, hook=FluxHook()) Result: $ python my_flux.py Actyon: my_reducer \u2713","title":"Flux"},{"location":"flux/#flux","text":"","title":"Flux"},{"location":"flux/#usage","text":"Define your store, like MyStore . Create a flux environment including the initial value for your store. from actyon.flux import Flux flux: Flux[MyStore] = Flux[MyStore](initial=initial_store) Create reducers like this: @flux.reducer async def my_reducer(state: MyStore, action: Flux.Action) -> MyState: # your magic code ... return state Optionally, add effects that are executed after successful reducers: @flux.effect(\"my_reducer\") async def my_effect(state: MyStore) -> None: # do whatever you want with the state, just don't expect alterations will affect other functions Finally, run your flux! await flux.run() await flux.dispatch(\"my_reducer\") await flux.done()","title":"Usage"},{"location":"flux/#example-counter","text":"Please find the code here . graph TD A[Run] --> B(Increment) B --> C{Is value < 10 ?} C --> B C -->D[Done]","title":"Example: Counter"},{"location":"flux/#experimental","text":"Registering a hook introduces a neat debug output on transitions: from actyon.flux import FluxHook flux: Flux[MyStore] = Flux[MyStore](initial=initial_store, hook=FluxHook()) Result: $ python my_flux.py Actyon: my_reducer \u2713","title":"Experimental"},{"location":"sm/","text":"State Machine Usage Define your State s and Transition s in your very own StateMachine : from actyon.sm import State, StateMachine, StateStore class MyMachine(StateMachine): state_1: State = State(\"state_1\") state_2: State = State(\"state_2\") state_1.to(state_2, \"my_trigger\") Afterwards you may want to add logic to your state changes. Feel free: my_machine: MyMachine = MyMachine() @my_machine.after(\"my_trigger\") async def after_my_trigger(state: StateStore, data: Dict[str, Any]) -> None: print(state.previous, \"->\", state.current) print(\"bomb went off:\", data.get(\"tick_tick\", \"puff\")) Finally, run your machine: await traffic_light.run() await traffic_light.trigger(\"my_trigger\", tick_tick=\"boom\") await traffic_light.done() Example: Traffic Light Please find the code here . stateDiagram-v2 [*] --> Red: run() Red --> [*]: done() Red --> Yellow: go Yellow --> Green: go Green --> Yellow: stop Yellow --> Red: stop Output: RYG \u25cf\u25cb\u25cb runtime: 0.0000 seconds \u25cb\u25cf\u25cb runtime: 0.0006 seconds \u25cb\u25cb\u25cf runtime: 1.0030 seconds \u25cb\u25cf\u25cb runtime: 5.0050 seconds \u25cf\u25cb\u25cb runtime: 1.0036 seconds Experimental Registering a hook introduces a neat debug output on transitions: from actyon.sm import StateHook my_machine: MyMachine = MyMachine(hook=StateHook()) Result: $ python my_machine.py Actyon: my_trigger \u2713 \u21e8 state: state_2","title":"State Machine"},{"location":"sm/#state-machine","text":"","title":"State Machine"},{"location":"sm/#usage","text":"Define your State s and Transition s in your very own StateMachine : from actyon.sm import State, StateMachine, StateStore class MyMachine(StateMachine): state_1: State = State(\"state_1\") state_2: State = State(\"state_2\") state_1.to(state_2, \"my_trigger\") Afterwards you may want to add logic to your state changes. Feel free: my_machine: MyMachine = MyMachine() @my_machine.after(\"my_trigger\") async def after_my_trigger(state: StateStore, data: Dict[str, Any]) -> None: print(state.previous, \"->\", state.current) print(\"bomb went off:\", data.get(\"tick_tick\", \"puff\")) Finally, run your machine: await traffic_light.run() await traffic_light.trigger(\"my_trigger\", tick_tick=\"boom\") await traffic_light.done()","title":"Usage"},{"location":"sm/#example-traffic-light","text":"Please find the code here . stateDiagram-v2 [*] --> Red: run() Red --> [*]: done() Red --> Yellow: go Yellow --> Green: go Green --> Yellow: stop Yellow --> Red: stop Output: RYG \u25cf\u25cb\u25cb runtime: 0.0000 seconds \u25cb\u25cf\u25cb runtime: 0.0006 seconds \u25cb\u25cb\u25cf runtime: 1.0030 seconds \u25cb\u25cf\u25cb runtime: 5.0050 seconds \u25cf\u25cb\u25cb runtime: 1.0036 seconds","title":"Example: Traffic Light"},{"location":"sm/#experimental","text":"Registering a hook introduces a neat debug output on transitions: from actyon.sm import StateHook my_machine: MyMachine = MyMachine(hook=StateHook()) Result: $ python my_machine.py Actyon: my_trigger \u2713 \u21e8 state: state_2","title":"Experimental"}]}